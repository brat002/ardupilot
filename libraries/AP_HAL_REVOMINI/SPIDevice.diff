--- SPIDevice.cpp	2017-12-06 08:32:37.000000000 +0500
+++ SPIDevice.cpp.bad	2017-12-06 11:29:11.509286211 +0500
@@ -181,54 +181,32 @@
 }
 
 
-// TODO eliminate usage of spimaster_transfer(), use interrupts instead
-
 bool SPIDevice::transfer(const uint8_t *out, uint32_t send_len, uint8_t *recv, uint32_t recv_len){
     
-    uint8_t ret=1;
+    uint8_t err=1;
 
 // differrent devices on bus requires different modes
-    if(owner[_desc.bus-1] != this) { // bus was in use by another driver so need reinit
+    if(owner[_desc.bus-1] != this) { // bus was in use by another driver so SPI hardware needs reinit
         _initialized=false;
     }
     
     if(!_initialized){
         init();
-        if(!_initialized) goto done;
+        if(!_initialized) return false;
         owner[_desc.bus-1] = this; // Got it!
     }
 
-#ifdef BOARD_SOFTWARE_SPI
-
-// not deleted for case of needs for external SPI on arbitrary pins
-
-    if(_desc.mode == SPI_TRANSFER_SOFT) {
-        spi_soft_set_speed();
 
         _cs_assert();
 
-
-        if (out != NULL && send_len) {
-            for (uint16_t i = 0; i < send_len; i++) {
-                _transfer_s(out[i]);
-            }    
-        } 
-    
-        if(recv !=NULL && recv_len) {
-            for (uint16_t i = 0; i < recv_len; i++) {
-                recv[i] = _transfer_s(0xff);
-            }
-        }
-
-        _cs_release();
-
-        if(_completion_cb) {
-            revo_call_handler(_completion_cb, (uint32_t)&_desc);
-            _completion_cb=0;
-        }
+#ifdef BOARD_SOFTWARE_SPI
+    if(_desc.mode == SPI_TRANSFER_SOFT){
+        spi_soft_set_speed();
     } else 
 #endif
     {
+        spi_set_speed(_desc.dev, determine_baud_rate(_speed)); 
+
         uint32_t t = hal_micros();
         while(_desc.dev->state->busy){ //       wait for previous transfer finished
             if(hal_micros() - t > 5000){
@@ -237,11 +215,11 @@
             }
             hal_yield(0);
         }
+    }
         
-        spi_set_speed(_desc.dev, determine_baud_rate(_speed));
         _desc.dev->state->busy = true; // we got bus
 
-        _send_address = out;    //      remember transfer params
+    _send_address = out;    //      remember transfer params for ISR
         _send_len     = send_len;
         _recv_address = recv;
         _recv_len     = recv_len;
@@ -321,7 +298,7 @@
                     }
                 }
             
-                ret = do_transfer(can_dma);
+            err = do_transfer(can_dma);
                 break;
             }
             // no break!
@@ -329,26 +306,49 @@
         case SPI_TRANSFER_INTR: // interrupts
             _isr_mode = _send_len ? SPI_ISR_SEND : SPI_ISR_RECEIVE;
             setup_isr_transfer();
-            ret=do_transfer(false);
+        err=do_transfer(false);
             break;
 
         case SPI_TRANSFER_POLL: // polling
-            ret = spimaster_transfer(_desc.dev, out, send_len, recv, recv_len);
-            _cs_release();
+        err = spimaster_transfer(_desc.dev, out, send_len, recv, recv_len);
+
             _desc.dev->state->busy=false;
+
+        _cs_release();
             if(_completion_cb) {
                 revo_call_handler(_completion_cb, (uint32_t)&_desc);
                 _completion_cb=0;
             }
             break;
 
+    case SPI_TRANSFER_SOFT:
+#ifdef BOARD_SOFTWARE_SPI
+// not deleted for case of needs for external SPI on arbitrary pins
+        if (out != NULL && send_len) {
+            for (uint16_t i = 0; i < send_len; i++) {
+                _transfer_s(out[i]);
+            }    
+        } 
+    
+        if(recv !=NULL && recv_len) {
+            for (uint16_t i = 0; i < recv_len; i++) {
+                recv[i] = _transfer_s(0xff);
+            }
+        }
+
+        _cs_release();
 
+        if(_completion_cb) {
+            revo_call_handler(_completion_cb, (uint32_t)&_desc);
+            _completion_cb=0;
+        }
+        err=0;
+        break;
+#endif
         default: 
             break;
         }
-    }
 
-done:
 #ifdef DEBUG_SPI 
     struct spi_trans &p = spi_trans_array[spi_trans_ptr];
 
@@ -373,14 +373,12 @@
 #endif
 
 
-    return ret==0;
+    return err==0;
 
 }
 
 
-
-
-
+// not used anywhere
 bool SPIDevice::transfer_fullduplex(const uint8_t *out, uint8_t *recv, uint32_t len) {
 
     if(owner[_desc.bus-1] != this) { // bus was in use by another driver so need reinit
@@ -393,32 +391,48 @@
     _cs_assert();
 
 #ifdef BOARD_SOFTWARE_SPI
-    if(_desc.mode == SPI_TRANSFER_SOFT) {
+    if(_desc.mode == SPI_TRANSFER_SOFT){
         spi_soft_set_speed();
-
-        if (out != NULL && recv !=NULL && len) {
-            for (uint16_t i = 0; i < len; i++) {
-                recv[i] = _transfer_s(out[i]);
-            }    
-        } 
     } else 
 #endif
     {
         spi_set_speed(_desc.dev, determine_baud_rate(_speed)); 
         
+        uint32_t t = hal_micros();
+        while(_desc.dev->state->busy){ //       wait for previous transfer finished
+            if(hal_micros() - t > 5000){
+            // TODO increment grab counter
+                 break; // SPI transfer can't be so long so let grab the bus
+            }
+            hal_yield(0);
+        }
+    }
+        
         switch(_desc.mode){
                 
         case SPI_TRANSFER_DMA:
-            if((out==NULL || ADDRESS_IN_RAM(out)) && (recv==NULL || ADDRESS_IN_RAM(recv)) ) {
+        if(ADDRESS_IN_RAM(out) && ADDRESS_IN_RAM(recv) ) {
                 setup_dma_transfer(out, recv, len);
-                return do_transfer(true);
+            return do_transfer(true)==0;
             }    
     
         // no break;
         case SPI_TRANSFER_INTR: // interrupts
             _isr_mode = SPI_ISR_RXTX;
             setup_isr_transfer();
-            return do_transfer(false);
+        return do_transfer(false)==0;
+
+    case SPI_TRANSFER_SOFT:
+#ifdef BOARD_SOFTWARE_SPI
+
+        if (out != NULL && recv !=NULL && len) {
+            for (uint16_t i = 0; i < len; i++) {
+                recv[i] = _transfer_s(out[i]);
+            }    
+        } 
+        _cs_release();
+        return true;
+#endif
 
         case SPI_TRANSFER_POLL: // polling
         default:
@@ -430,7 +444,6 @@
             _cs_release();
             return true;
         } 
-    }
     return false;
 }
 
@@ -465,7 +478,7 @@
     if(_desc.cs_pin < BOARD_NR_GPIO_PINS) {
         _cs = REVOMINIGPIO::get_channel(_desc.cs_pin);
         if (!_cs) {
-            AP_HAL::panic("Unable to instantiate cs pin");
+            AP_HAL::panic("SPI: wrong CS pin");
         }
     } else {
         _cs = NULL; // caller itself controls CS
@@ -554,49 +567,61 @@
 static uint32_t rw_workbyte[] = { 0xffff }; // not in stack!
 
 void  SPIDevice::setup_dma_transfer(const uint8_t *out, const uint8_t *recv, uint32_t btr){
-    DMA_InitTypeDef DMA_InitStructure;
-    DMA_StructInit(&DMA_InitStructure);
+    DMA_InitType DMA_InitStructure;
 
     const Spi_DMA &dp = _desc.dev->dma;
+    uint32_t memory_inc;
 
     dma_init(dp.stream_rx); dma_init(dp.stream_tx);
 
     dma_clear_isr_bits(dp.stream_rx); dma_clear_isr_bits(dp.stream_tx);
 
-    /* shared DMA configuration values */
-    DMA_InitStructure.DMA_Channel               = dp.channel;
-    DMA_InitStructure.DMA_PeripheralBaseAddr    = (uint32_t)(&(_desc.dev->SPIx->DR));
+    // shared DMA configuration values - fixed
+/*
     DMA_InitStructure.DMA_PeripheralDataSize    = DMA_PeripheralDataSize_Byte;
     DMA_InitStructure.DMA_MemoryDataSize        = DMA_MemoryDataSize_Byte;
     DMA_InitStructure.DMA_PeripheralInc         = DMA_PeripheralInc_Disable;
-    DMA_InitStructure.DMA_BufferSize            = btr;
     DMA_InitStructure.DMA_Mode                  = DMA_Mode_Normal;
-    DMA_InitStructure.DMA_Priority              = _desc.prio; 
-    DMA_InitStructure.DMA_FIFOMode              = DMA_FIFOMode_Disable;
+    DMA_InitStructure.DMA_FIFOMode              = DMA_FIFOMode_Disable; // TODO use FIFO on large transfers
     DMA_InitStructure.DMA_FIFOThreshold         = DMA_FIFOThreshold_Full;
     DMA_InitStructure.DMA_MemoryBurst           = DMA_MemoryBurst_Single;
     DMA_InitStructure.DMA_PeripheralBurst       = DMA_PeripheralBurst_Single;
  
+    DMA_InitStructure.DMA_Channel               = dp.channel;
+*/
+
+    DMA_InitStructure.DMA_FIFO_flags = DMA_FIFOThreshold_Full | DMA_FIFOMode_Disable; // TODO use FIFO on large transfers                                       
+
+    DMA_InitStructure.DMA_PeripheralBaseAddr    = (uint32_t)(&(_desc.dev->SPIx->DR));
+    DMA_InitStructure.DMA_BufferSize            = btr;
+ 
   // receive stream
-    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
     if(recv) {
       DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)recv;
-      DMA_InitStructure.DMA_MemoryInc       = DMA_MemoryInc_Enable;
+      memory_inc                            = DMA_MemoryInc_Enable;
     } else {
       DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)rw_workbyte;
-      DMA_InitStructure.DMA_MemoryInc       = DMA_MemoryInc_Disable;
+      memory_inc                            = DMA_MemoryInc_Disable;
     }
+    
+    DMA_InitStructure.DMA_flags      = DMA_PeripheralDataSize_Byte | DMA_MemoryDataSize_Byte | 
+                                       DMA_PeripheralInc_Disable | DMA_Mode_Normal | 
+                                       DMA_MemoryBurst_Single | DMA_PeripheralBurst_Single | 
+                                       dp.channel | DMA_DIR_PeripheralToMemory | memory_inc | _desc.prio;
     dma_init_transfer(dp.stream_rx, &DMA_InitStructure);
 
   // transmit stream
-    DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
     if(out) {
       DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)out;
-      DMA_InitStructure.DMA_MemoryInc       = DMA_MemoryInc_Enable;
+      memory_inc                            = DMA_MemoryInc_Enable;
     } else {
       DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)rw_workbyte;
-      DMA_InitStructure.DMA_MemoryInc       = DMA_MemoryInc_Disable;
+      memory_inc                            = DMA_MemoryInc_Disable;
     }
+    DMA_InitStructure.DMA_flags      = DMA_PeripheralDataSize_Byte | DMA_MemoryDataSize_Byte | 
+                                       DMA_PeripheralInc_Disable | DMA_Mode_Normal | 
+                                       DMA_MemoryBurst_Single | DMA_PeripheralBurst_Single | 
+                                       dp.channel | DMA_DIR_MemoryToPeripheral | memory_inc | _desc.prio;
     dma_init_transfer(dp.stream_tx, &DMA_InitStructure);
 
     dma_enable(dp.stream_rx); dma_enable(dp.stream_tx); // run them both!
